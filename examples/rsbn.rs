extern crate clap;
extern crate rsgm;
extern crate serde;
extern crate serde_json;

use clap::Parser;
use rsdd::{builder::{decision_nnf::{StandardDecisionNNFBuilder, DecisionNNFBuilder}, sdd::{CompressionSddBuilder, SddBuilder}, bdd::{RobddBuilder, BddBuilder}, cache::all_app::AllTable, BottomUpBuilder}, repr::{var_order::VarOrder, ddnnf::DDNNFPtr, vtree::VTree, dtree::DTree, bdd::BddPtr, var_label::{Literal, VarLabel}}};
use rsgm::{BayesianNetwork, BayesianNetworkCNF};
use std::{fs, time::Instant, collections::HashMap};

/// Processes a JSON Bayesian network generated by `converter`
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// An input Bayesian network file in JSON format
    #[clap(short, long, value_parser)]
    file: String,

    /// The compile mode (either 'bdd' or 'sdd')
    #[clap(short, long, value_parser)]
    mode: String,

    /// The elimination order (either 'topological' or 'force')
    #[clap(short, long, value_parser, default_value = "topological")]
    elim: String,

    /// The type of query to perform. Options: "marginal"
    #[clap(short, long, value_parser)]
    query: Option<String>,

    /// Name of a variable to query
    #[clap(long, value_parser)]
    query_var: Option<String>,

    /// Name of a variable value to query
    #[clap(long, value_parser)]
    query_value: Option<String>,
}

fn compile_bdd_cnf(args: &Args, network: BayesianNetwork) {
    let bn = BayesianNetworkCNF::from_bayesian_network(&network);
    let compiler = RobddBuilder::<AllTable<BddPtr>>::new_default_order(bn.cnf().num_vars());

    println!("Compiling...");
    let start = Instant::now();
    let r = compiler.compile_cnf(bn.cnf());
    let duration = start.elapsed();
    let sz = r.count_nodes();
    println!("Compiled\n\tTime: {:?}\n\tSize: {sz}", duration);

    match &args.query {
        Some(q) if q.eq("marginal") => {
            let query_var = args
                .query_var
                .as_ref()
                .unwrap_or_else(|| panic!("Provide query variable for marginalization"));
            let query_val = args
                .query_value
                .as_ref()
                .unwrap_or_else(|| panic!("Provide query variable value for marginalization"));
            let indic = bn.indicator(query_var, query_val);
            // let cond = compiler.condition(r, indic, true);
            let v = compiler.var(indic, true);
            let cond = compiler.and(r, v);
            let p = cond.wmc(compiler.get_order(), bn.params());
            let z = cond.wmc(compiler.get_order(), bn.params());
            println!(
                "Marginal query: Pr({query_var} = {query_val}) = {p}, z = {z}, p / z = {}",
                p.0 / z.0
            );
        }
        _ => (),
    }
}

fn compile_bdd(_args: &Args, network: BayesianNetwork) {
    let compiler = RobddBuilder::<AllTable<BddPtr>>::new_default_order(1);

    // let mut clauses : Vec<Vec<Literal>> = Vec::new();
    let mut wmc_params: HashMap<VarLabel, (f64, f64)> = HashMap::new();

    // create one indicator for every variable assignment
    // maps Variable Name -> (Variable Assignment -> Label)
    let mut indicators: HashMap<String, HashMap<String, VarLabel>> = HashMap::new();

    let mut cpts: Vec<BddPtr> = Vec::new();

    for v in network.topological_sort() {
        // create this variable's indicators and parameter clauses
        let mut cur_cpt = BddPtr::true_ptr();

        let mut cur_indic: Vec<Literal> = Vec::new();
        indicators.insert(v.clone(), HashMap::new());
        for varassgn in network.all_possible_assignments(&v) {
            let cur_var = compiler.new_label();
            let new_indic = Literal::new(cur_var, true);
            wmc_params.insert(cur_var, (1.0, 1.0));
            cur_indic.push(new_indic);
            indicators
                .get_mut(&v)
                .unwrap()
                .insert(varassgn.clone(), cur_var);

            for passgn in network.parent_assignments(&v) {
                let cur_param = compiler.new_label();
                let cur_param_v = compiler.var(cur_param, true);
                let cur_prob = network.conditional_probability(&v, varassgn, &passgn);
                wmc_params.insert(cur_param, (1.0, cur_prob));

                // build cur_param => cur_assgn /\ cur_indic
                let mut indic: BddPtr =
                    passgn
                        .iter()
                        .fold(BddPtr::true_ptr(), |acc, (varname, varval)| {
                            let varlabel = indicators[varname][varval];
                            let v = compiler.var(varlabel, true);
                            compiler.and(acc, v)
                        });
                let indic_var = compiler.var(cur_var, true);
                indic = compiler.and(indic_var, indic);

                let iff = compiler.iff(indic, cur_param_v);
                cur_cpt = compiler.and(cur_cpt, iff);
            }
        }

        // build exactly-one for indicator clause
        let mut exactly_one = BddPtr::true_ptr();
        for x in 0..(cur_indic.len()) {
            for y in (x + 1)..(cur_indic.len()) {
                let v1 = compiler.var(cur_indic[x].get_label(), false);
                let v2 = compiler.var(cur_indic[y].get_label(), false);
                let or = compiler.or(v1, v2);
                exactly_one = compiler.and(exactly_one, or);
            }
        }
        let o2 = cur_indic.iter().fold(BddPtr::false_ptr(), |acc, i| {
            let v = compiler.var(i.get_label(), true);
            compiler.or(acc, v)
        });

        let new = compiler.and(cur_cpt, o2);
        cpts.push(new);
    }
    let r = cpts.iter().fold(BddPtr::true_ptr(), |acc, cpt| {
        println!(
            "cur size: {}, cpt size: {}",
            acc.count_nodes(),
            cpt.count_nodes()
        );
        compiler.and(acc, *cpt)
    });
    println!("final size: {}", r.count_nodes());
}

fn compile_sdd_cnf(network: BayesianNetwork) {
    println!("############################\n\tCompiling in SDD mode\n############################");
    let bn = BayesianNetworkCNF::from_bayesian_network(&network);
    // println!("{}", cnf.to_dimacs());
    println!("Building dtree");
    let start = Instant::now();
    let dtree = DTree::from_cnf(bn.cnf(), &VarOrder::linear_order(bn.cnf().num_vars()));
    let duration = start.elapsed();
    println!("Dtree built\nNumber of variables: {}\n\tNumber of clauses: {}\n\tWidth: {}\n\tElapsed dtree time: {:?}",
        bn.cnf().num_vars(), bn.cnf().clauses().len(), dtree.cutwidth(), duration);

    let compiler = CompressionSddBuilder::new(VTree::from_dtree(&dtree).unwrap());

    println!("Compiling");
    let start = Instant::now();
    let r = compiler.compile_cnf(bn.cnf());
    let duration = start.elapsed();
    let sz = r.count_nodes();
    println!("Compiled\n\tCompile time: {:?}\n\tSize: {sz}", duration);
}

fn compile_topdown(network: BayesianNetwork) {
    println!("############################\n\tCompiling topdown\n############################");
    let bn = BayesianNetworkCNF::from_bayesian_network(&network);
    let order = VarOrder::linear_order(bn.cnf().num_vars());
    let compiler = StandardDecisionNNFBuilder::new(order);

    println!("Compiling");
    let start = Instant::now();
    let r = compiler.compile_cnf_topdown(bn.cnf());
    let duration = start.elapsed();
    let sz = r.count_nodes();
    println!("Compiled\n\tCompile time: {:?}\n\tSize: {sz}", duration);
}

fn print_dimacs(bn: BayesianNetwork) {
    let bn = BayesianNetworkCNF::from_bayesian_network(&bn);
    println!("p cnf {} {}", bn.cnf().clauses().len(), bn.cnf().num_vars());
    println!("{}", bn.cnf().to_dimacs());
}

fn main() {
    let args = Args::parse();
    let bn = BayesianNetwork::from_json(fs::read_to_string(&args.file).unwrap().as_str());
    match args.mode.as_str() {
        "sdd" => compile_sdd_cnf(bn),
        "bdd" => compile_bdd(&args, bn),
        "bdd_cnf" => compile_bdd_cnf(&args, bn),
        "topdown" => compile_topdown(bn),
        "print_dimacs" => print_dimacs(bn),
        _ => panic!("unrecognized mode"),
    }
}
